# 指针和内存
-----

## 一.基本概念

### 1.c 在编译后会以以下形式使用内存

- 静态/全局变量：程序开始时分配，结束时消失；所有函数都能访问全局变量，静态变量则限定到定义的函数（或文件）内部。
- 自动变量：函数内部声明。
- 动态内存：分配在堆上。
### 2.const修饰的指针

```c
const int *p;     //指向const int 的指针，不能解引从而修改指向的数据。
int const *p;     //同上
int *const p;     //指向整形变量的常指针，不能再指向别的变量，但指向的变量值可以改，
```
**关键看const 右边修饰的是什么**

### 3.null的概念

- null指针常量：指针包含了一个特殊的值，和别的指针不一样，没有指向任何内存区域。两个null指针总是相等的。
- NUll宏定义：强制类型转换为 void\*的整数常量0。#define NULL ((void)* 0)
- ASCII字符NUL：'\0'。
- null语句：只有分号的语句。

>NULL指针和未初始化的指针不同，未初始化的指针可能包含任何值，而包含NULL的指针则不会引用内存中任何地址。
### 4.void 指针

- void指针具有char指针相同的形式和内存对齐方式
- void指针和别的指针永远不会相等（赋值为null的除外）
- void指针可以存放任何数据类型的引用。 
- void指针可以赋值给其他任何指针类型。  

>指针被声明为全局或静态，就会在程序启动时被初始化为NULL；
### 5.指针相关预定义类型

- `size_t`:用于安全地表示长度；提供一种可移植的方法来声明与系统中可寻址的内存区域一致的长度，无符号数。
- `ptrdiff_t`：用于处理指针算术运算
- `intptr_t `和 `uintptr_t`：用于存储指针地址，提供了一种可移植且安全的方法声明指针，而且和系统中使用的指针长度相同；**对于把指针转化为整数形式来说很有用**
### 6.指针操作符

- 指针加（减）一个整数实际上加的数就是这个整数和当前指针数据类型对应的字节数的乘积。  
- **指针相减**：相当于指针算数运算的变形，`ptrdiff_t`类型表示两个指针差值的可移植方式。

-----

## 二.c的动态内存管理

### 1.动态内存分配

- 内存泄露：丢失地址（`melloc()`后首地址丢失），应该调用`free`没有调用
- 动态内存分配：`malloc、realloc、calloc、free`（释放）。
- `malloc`：从堆上分配内存，返回首地址，不能声明为`static`（static修饰静态链接，存放在数据区data）。
- `free`:申请的对台内存地址前一个位置会存储此地址申请的动态内存的大小，所以:
    - 1.free一定要传入正确指针
    - 2.free仅传入指针即可；free后尽量将指针赋值NULL；避免重复释放（释放仅仅是通知操作系统这块内存又可以重新使用，并不会删除指针变量，指针变量还会指向该地址）
### 2.迷途指针

- **如果内存已经释放，而指针还在引用原始内存，这样的指针就成为迷途指针。迷途指针没有指向有效对象，有时候也称为过早释放。特别是两个指针指向同一个堆内地址时需特别注意。**

### 3.动态内存分配技术

----

##三.指针和函数

### 1.程序的栈和堆

- 程序栈是支持函数执行的内存区域，通常和堆共享。通常栈在下部，堆在上部。
- 调用函数时，栈向上长出一个栈帧。函数终止栈帧从程序栈弹出。
- 栈帧：返回地址、局部数据存储、参数存储、栈指针和基地址。（参见计算机原理）
### 2.通过指针传递和返回数据

- 用指针来传递数据的一个主要原因是函数可以修改数据。
- 传递一个指针用来减少数据的拷贝，例如数组和字符串。
### 3.函数指针

- 函数指针是持有函数地址的指针
- 函数指针声明：
```C
int (*founc(int, int)); //需要两个int类型参数，返回类型为int的函数指针
```
- 函数名即为函数地址:`f`和`f()`不同，前者指函数地址，后者指函数调用==（）为函数调用符号==；

-----

## 四.指针和数组

### 1.数组概述

- 数组是能用索引访问的同质元素连续集合。（连续是指元素在内存中是相邻的，中间不存在间隙）
#### 指针表示法和数组
- `int a[5]`:单独使用数组名 a 表示数组第一个元素的地址, a+1 表示第二个元素；&a表示数组的地址，&a+1 表示数组后面的那个地址。注意区分。
- 数组名和指针的区别：调用`sizeof()`时，传入的如果是==数组名，则返回整个数组的字节数，如果是指针，则返回地址长度==。
>其实，数组下标表示方式为语法糖，本质为a[i] --> a+i， 所以，数组也可写为i[a] --> i+a，很神奇！！！
### 2.传递多维数组

- 例如 `int arr[2][5];` 数组(5个元素)的数组（2个元素）,`[[*], [*], [*], [*], [*]], [[*], [*], [*], [*], [*]]`
- 传递arr可以这样写：`void display（int arr[][5], int rows);`
- 或者：`void display(int (*arr)[5], int rows);      // 注意 *arr 的括号 arr[rows][5], arr是一个指向拥有5个元素的数组的指针。`
- 传递三维数组：`void display(int(*arr)[3][5], int rows);  // 数组arr[rows][3][5]`
### 3.动态分配二维数组

需要关系的几个问题：1，数组元素是否需要连续；2，数组是否规则

----

## 五. 指针和字符串

### 1.字符串基础

- 声明：字面量、字符数组、指针
- 字符串的字面量一般分配在**只读内存**中，不可改变，字符串字面量不存在作用域的概念（注意，是字面量！）。
- 字符串的初始化：初始化char数组、初始化char指针（动态分配内存）。
### 2.标准字符串的操作 `<string.h>`

- 比较 `strcmp()`: 返回负，0（==相等返回0==），正
- 复制 `strcpy()`：函数不保证空间大小，只判断指针是否正确；
- 拼接 `strcat()`:需注意，第一个字符串空间要足够容纳第二个，函数不会负责空间大小问题。
### 3.传递字符串

###4.返回字符串

- 返回字面量的地址
- 返回动态分配内存的地址（函数调用者需要释放动态申请的内存）

##六. 指针和结构体

结构体增强了**数组等集合**的实用性，利用结构体数组可以方便的具有多个属性的一类对象的集合
### 1.介绍

- 结构体定义和声明：  

  ```c
  struct stu  
      {   
      .....   
      };   
  // struct stu即为这个结构体的类型，声明时：struct stu student1, sutdent2;
  ```


- 利用typedef:  

  ```c
  typedef struct (str,可有可无)  
          { 
          .....   
          } str;
  ```


- 为结构体分配内存：分配内存的大小至少为各字段的长度和，实际长度通常会大于这个和，因为各字段之间可能会有填充（内部可能需要对齐到特定地址）
- 结构体内部对齐原则：==自然对齐==：编译器按每个成员size最大的成员进行对齐，保证不超过，size小的合并；
- 指定边界对齐：使用伪指令`#pragma pack (n)`，编译器将按照n个字节对齐，使用伪指令`#pragma pack ()`，取消自定义字节对齐方式。
- 在为结构体分配内存时，运行时系统不会自动为结构体内部的指针分配内存。类似的，当结构体消失时，运行时系统也不会自动释放结构体内部的指针指向的内存。
- 对于上述结构体，一般的方式维护需要频繁的申请和释放内存。解决方法，建立一个结构体池，当我们需要某个示例时，从结构体池中取出一个对象，如果没有可用的元素，再动态分配。
### 2.指针支持数据类型

链表、队列（FIFO）、栈（FILO）、树   
- 树 子节点连接到父节点，从整体上看就像一颗倒过来的树，**根节点**表示这种数据结构的开始元素；树可以有任意数量的子节点，不过最常见的就是二叉树。
- `typedef struct _tree { void *data; struct _tree *left; struct _tree *right;}` TreeNode;
- 按照特定的顺序向树中插入节点是有意义的（参见数据结构）

## 七.安全问题和指针误用

### 1.指针的声明和初始化

- 不恰当的初始化，例如：

  ```c
  int* ptr1， ptr2； 					//声明含义，ptr1为int指针，ptr2为int
  ```

- 使用指针前未初始化：仅声明一个指针是不够的，还需要将指针指向一个确切的地址，（未初始化的指针有时称为野指针）
### 2.指针的使用问题。

指针使用安全问题聚焦的是**缓冲区溢出**的概念。
- 测试NULL，例如用`malloc()`函数时一定要检查返回值，否则可能会导致程序的非正常终止。

- 正确使用`* `、` & `，

- 迷途指针：已经释放，但仍指向原位置的指针。

- 越过数组边界访问内存

- 错误计算数组长度，将数组传递给函数时一定同时传递数组长度。

- 正确使用 sizeof( ) 函数，sizeof()返回**字节数**，需要注意！

- 匹配正确的指针类型，（指针类型决定了使用该地址上数据的解读方式，解读方式的不同，结果将发生巨大变化）

- 字符串的安全问题，使用字符串相关函数时：`strcpy(), strcat()`, 请务必详细了解相关函数的实现过程，具有很深的学习性。

  ```c
  char *strcpy(char *strDest, const char *strSrc)
  {
      if ( strDest == NULL || strSrc == NULL)				// 检查指针是否正确
          return NULL ;
      if ( strDest == strSrc)								// 检查是否是同一个字符串
          return strDest ;
      char *tempptr = strDest ;							// 保存初始值，用于返回
      while( (*strDest++ = *strSrc++) != ‘\0’);			// 循环赋值，直到遇到`\0`
          return tempptr ;								// 返回
  }
  ```

  ​

- 指针算术运算和结构体：由于结构体的存放可能不是连续的，所以特别注意结构体成员的存储位置。

- 函数指针：例如`void(*f)(int)`，需要一个int类型参数，返回为void类型的函数指针；