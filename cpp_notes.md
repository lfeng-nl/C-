# CPP
## 1.基础知识
- 变量的初始化：直接初始化（`int x(12) `）和复制初始化（` int x = 12 `）；

- 命名空间：使用命名空间(`using namespace NAME`)，定义命名空间（`namespace NAME`）；

- 引用：就是变量的别名、外号；必须绑定到具体的对象（变量）才有意义；

- c++函数新特性：默认参数，函数重载，内联函数（inline）

- 内存申请：**申请和释放的方式要对应**
  ``` c++
    // 申请一个类型的内存
    int *a = new int;
    // 需要检查申请是否成功
    if(NULL == a){
    
    }
    // 释放内存空间
    delete a;
    // 申请一块内存
    int *b = new int[10];
    delete []b ;
  //申请一个类内存时可以类名加（），初始化这个类
  ```

- new/delete和malloc/free区别：

  - new从自由存储区上为对象分配内存空间，而malloc从堆上动态分配内存；自由存储区时C++基于new操作符的一个抽象概念，可以是堆，也可以不是堆；
  - malloc/free是库函数，new/delete是c++操作符；
  - 参数：new可以不知名内存大小，由编译器推测，malloc必须显示指定大小；
  - 返回类型：new分配成功返回对象指针，类型严格与对象匹配，无需类型转换；malloc返回`void*`，需要类型转换；
  - 分配失败：new会抛出异常bac_alloc异常，也会返回NULL；malloc返回NULL；
  - 自定义类型：new会先调用`operator new`非配内存，再调用构造函数，初始化对象；delete先调用析构函数，再释放内存；malloc只负责申请一段内存区域；

- 动态内存`delete`掉之后要将指针值赋为`NULL`，避免悬空指针的问题；

- 初始化列表：当有常量数据成员时必须用初始化列表来初始化

  ```c++
  class Student
  {
      Student(int x, int y):a(x),b(y){};
  private:
      int a;
      int b;
  }
  ```

- 模版：模版（函数模版和类模版）本身并不是类或函数，相反，可以将模版看作**为编译器生成类或函数编写的说明**。一般需要提供额外的信息来指定模版到底事例化成什么样的类型。

- 字符编码：ASCII、Unicode、UTF-8、UTF-16
    - ASCII：
    - Unicode：是计算机科学领域里的一项业界标准,包括字符集、编码方案等，Unicode只是一个用来映射字符和数字的标准。它对支持字符的数量没有限制，也不要求字符必须占两个、三个或者其它任意数量的字节。两个最流行的Unicode编码方案是UTF-8和UTF-16。
    - UTF-8：当用UTF-8时表示一个字符是可变的，可以是一个、两个、或三个字节，`0xxxxxxx 或 110xxxxx 10xxxxxx 或 1110xxxx 10xxxxxx 10xxxxxx`；
    - UTF-16：任何字符对应的数字都用两个字节来保存；
    - 还需要在文本使用 `EF BB BF` 三个字节表示使用 UTF-8 编码;使用` FE FF `表示使用 UTF-16 编码。

- 范围`for()`：

    ```c++
    /* 
    for(declaration:expression)
      	statement
    */
    vector<int> v={0,1,2,3,4};
    for(auto &a:v){					//对于v中的每个元素
      cout << a << " ";
    }
    cout << endl;
    ```

- 函数的**声明** 和 **定义**：声明无函数体，定义有函数体；函数声明也叫函数原型；

- 函数参数传递：

    - 值传递：存入一般值或指针，需要拷贝；
    - 引用传递：不用拷贝；

- 函数返回类型：

  - 调用一个返回引用类型的函数得到左值；

  - 其他返回右值；

  - c++11规定，函数可以返回花括号包围的值的列表；

    ```c++
    vector<string> process()
    {
      //expected 和 actual是string对象
      if(expected.empty())
        return{};
      else if(expected == actual)
        return{"functionX", "okay"};
    }
    ```

- 尾置返回类型和decltype：

    - 尾置，在参数列表后面指定的类型，例如
      ```c++
      // func接受一个int类型的实参，返回一个指针，指向一个含有10个整数的数组
      auto func(int i) -> int(*)[10]	
      ```

    - decltype：

      ```c++
      // 函数attPty()返回指针，该指针指向一个4个元素数组；

      int odd[] = {1,2,3,4};
      decltype(odd) *attPty(int i)
      {
        
      }
      ```

- 函数重载：函数名相同但形参列表不同，（数量不同或类型不同）

- 默认实参：

- 函数指针：指向的是函数而非对象，函数指针同样需要确定对象，函数返回类型，参数类型和个数；

- 内联函数：用inline关键字修饰，编译时将函数体嵌入到每一个调用处；而非调用时的函数转移；可以消除函数调用的时间；inline只是向编译器建议内联，具体实施与否需要看编译器。

---
## 2.类相关

- 类的基本思想：数据抽象（data abstration）和封装（encapsulation）】

- 访问控制：c++使用“访问说明符”来加强封装性

  - public
  - private
  - protected



### a.普通成员函数和普通数据成员

- 成员函数为整个类共有，会隐式的传入一个this指针来表明是哪一个对象；

- this指针：当调用类的成员函数时，会隐式的传入一个this指针，例如

  ```c++
  one.set(10,10);		//调用成员函数
  //编译器会重写这个函数，实际调用
  Point::set(&one, 10, 10);
  ```

- 普通数据成员为对象所有，对象创建的时候进行创建；
### b.静态成员函数和静态数据成员

- 静态数据成员：数据成员的声明前加上static关键字，具有以下特点：

    - 静态数据成员实际上是全局变量；
    - 静态数据成员被类的所有对象共享，包括派生类的对象；
    - 静态数据成员可以成为成员函数的可选参数，而普通数据成员不行；
    - 静态数据成员可以是所属类的类型；
    - 静态数据成员必须**类外初始化**，初始化后才能使用（静态常亮成员除外），一般放在类的实现文件中初始化（cpp）例如：`int ClassName::a;`；
- 静态成员函数：地址可以用普通函数指针存储，而普通的成员函数（非静态）需要用类成员函数指针来存储；静态成员函数**不含有this指针**；类似普通函数，只是和某个类进行了绑定；不能访问非静态成员；
- 静态成员（包括数据和对象）可以独立访问，而无需创建任何对象，`ClassName::member`，也可以对象调用`obj.member`；

### c.常成员函数和常数据成员

- 常数据成员：只能通过初始化列表初始化;

- 常成员函数：函数后用const修饰，实际修饰的是this指针，this指向的东西是常量，里面的内容不变；
    ```c++
    void test() const
    {
    };
    ```
    - 不能用来更新类的成员
    - 不能调用未用const修饰的成员函数；
    - 常成员函数可以重载；
    - 扩展：对于常对象的引用或指针都只能调用常量成员函数；

- 常对象：只能调用常成员函数；

### d.继承

- 父类（基类），子类（派生类）

- 隐藏和覆盖:当子类与父类存在同名函数时，子类函数会将父类的函数隐藏，默认调用子类的函数；如果希望调用父类的函数，需要在函数名前加上`clase_name::foun()`;
  > 注意：子类函数无法构成父类函数的重载，只能隐藏；

- 虚继承：为了避免菱形继承中，对底层的子类继承多份最顶层的父类；内存中有多个等成父类空间的现象；继承的时候，加上virtual，就构成虚继承；注意：每个子类都要加virtual

  - C++规则：如果在继承链上存在虚继承的基类，则最底层的子类要负责完成该虚基类部分成员的构造。

- 基类的静态成员，无论派生出了多少个派生类，只有一个实例；

- 继承方式：

    - 公有继承：基类的**公有成员和保护成员**在派生类中**保持**原有访问属性，私有成员为基类私有，派生类无访问权限；
    - 私有继承：基类的**所有成员**在派生类中为**私有成员**；基类私有成员为基类私有，派生类无权访问；
    - 保护继承：**基类的公有成员和保护成员**在派生类中成了**保护成员**，基类私有成员为基类私有，派生类无权访问；
    - 综上所述：1.基类的私有成员，只有基类和基类有元可以访问；无论怎么继承，派生类都无权访问；2.原有属性会根据继承属性进行降级；3.保护继承和私有继承会将基类访问权限降级；4.一般，**保护继承和私有继承在实际的编程中极少用到，只在技术理论上有意义**
    - 继承时，请使用公有继承（public）

- 赋值兼容规则：在需要使用基类对象的任何地方，都可以使用**公有派生类**的对象来替代；

- 派生类的构造和析构顺序：

    - 构造顺序：调用基类构造函数-->执行派生类初始化列表-->执行派生类初始化函数体；
    - 析构顺序：对派生类新增成员清理-->子对象的析构函数-->基类析构函数

- 多继承：一个子类继承多个父类，例如`class C:public A,public B`，每个继承的类前都要加继承方式；

- 多重继承：`class B:public A`,`class C:public B`；

- 二义性：多个基类可能出现同名的成员，在派生类中对这种同名成员的访问是不确定的。必须加限定符`ClassName::`来限定是那个基类的；

- 对象的内存分布：

    - 一般继承：父类在前，子类在后；
    - 虚继承：首地址为一个指针，其次为父类，其次为子类，最后为虚基类；

- 虚基类（虚继承）：避免菱形继承时，基类重复继承，导致的二意性问题；

    - 虚继承：在继承中用virtual关键字来修饰；

    - 虚基类：在集成体系中通过virtual继承而来的基类；

    - 如果在虚基类中定义了带参数的构造函数，而且没有定义默认构造函数，则在所有派生类中，都要通过构造函数的初始化表对虚基类进行初始化。

      ```c++
      class A;									// 若A的构造函数带参数
      {
       	A(int a):x(a){}
      }
      class B :virtual public A;			 		// 需要对A进行初始化
      {
        B(int a):A(a){}
      }
      class C :virtual public A;					// 需要对A进行初始化
      {
        C(int a):A(a){}
      }
      class D :virtual public B, virtual public C;// 需要对进行初始化
      {
        D(int a):A(a),B(a),C(a){}
      }
      ```

### e.类的作用域和对象的声明周期

- 类的作用域：每个类都有自己的作用域;
- 每个对象都有自己的生命周期；

### f.有元

允许将非公有的数据成员的访问权赋予指定的函数或类；

- 友元函数

    - 有元全局函数：`fri_func()`可以直接访问类T的私有成员

        ```c++
        class T
        {
          friend void fri_func(T& t);
          ...
        }

        void fri_func(T& t)
        {
          t.member			//可以直接访问t的私有数据成员
            ....
        }
        ```

    - 有元成员函数：可以直接访问类T的私有数据成员

        ```c++
        class T
        {
          firend void Cir::fri_fnuc();
          ...
        }
        ```

- 有元类

    ```c++
    class ClassName
    {
      friend ClassName_friend;
      ...
    }
    ```

    ​

------

## 3.构造和析构

每个类都分别定义了它的对象被初始化的方式，类通过一个或几个特殊的成员函数来控制其对象的初始化过程，这些函数叫做**构造函数**；

### a.构造函数

- 构造函数与类名相同，且没有返回类型；

- 如果成员是const、引用，或属于某种未提供默认构造函数的类类型，必须通过构造函数提供初始值；

- 默认构造函数：不带参数的构造函数，或者所有形参都有默认值；**当一个类哪怕只定义了一个构造函数，编译器也不会再生成默认构造函数， 即，当我们为类定义了一个带参数的构造函数后，编译器不会再生成默认构造函数；如何还需要默认构造函数，则需要定义，如果不定义，当声明一个无初始值的对象时，会出错。**

- 关键词：explicit，请看一下代码

  ```C++
  class Test
  {
    public:
    	Test(int x):t(x)
      {
        cout << "Test()" << endl;
      }
    	~Test(){};
    private:
    	int t;
  }
  int main()
  {
    Test t = 12;				
    /*编译器会调用构造函数,打印“Test()”;一般构造函数还是一个默认且隐含的类型转换操作符，explicit就是防止隐式转换的，声明构造函数时时添加在函数名前；
    
    */
  }
  ```

### b.复制构造函数

- 复制构造函数（拷贝构造函数）：用**对象初始化另一个对象**，定义方式（固定方式，有且仅有一个形参）：

  ```c++
  ClassName (const ClassName& obj)
  {
    funcBody；
  }
  ```

- 每个类必须有个复制构造函数，如果没有定义，则编译器会自动合成一个，成为**合成复制构造函数**，会把非静态成员逐个拷贝；

- 深复制(拷贝)和浅复制(拷贝)：

  - 深复制：拷贝指针指向区域的资源； 
  - 浅复制：只拷贝指针值；指针指向地址的内容未复制；

- C++初始化方式：直接初始化`ClassName c1(1,2);`或`ClassName c2(c1)`；复制初始化`ClassName c = c1;`

- 函数形参为对象类型，而非指针或引用时，函数会调用复制构造函数，产生一个副本，类似情况还有函数返回时；


### 析构函数


- 析构函数：对象脱离其作用域时， 或delete一个动态建立的对象；

- 合成析构函数：编译器自动生成的，会按成员对象的声明顺序的逆序，销毁对象；

- 析构函数三法则：如果一个类需要定义自己的析构函数，则这个类必然需要定义自己的复制构造函数，和赋值运算符重载；


-------

## 4.多态

面向对象程序设计的真正力量不仅仅是继承，而是允许派生类对象向基类对像一样处理，其**核心机制就是多态和动态联编(动态关联，动态绑定，在编译时并不能确切知道需要调用的函数，只有在程序运行时才能确定将要调用的函数)。**

### a.多态的基本概念

- 多态：允许将子类类型的指针赋值给父类型的指针；然后通过父类的指针（或引用）调用实际子类的成员函数。这种技术可以让父类指针有“多种状态”，是一种泛型技术；
  - 泛型技术：利用不变的代码实现可变的算法；如模板技术、RTTi技术、虚函数技术等
- 重载多态：（重载也是一种多态），分为函数重载和运算符重载；
- 强制多态：（强制类型转换），有一下几种表达式，`static_cast<T>(E); T(E); (T)E`
- 类型参数化多态：类模板，函数模板；
- 包含多态：虚函数实现，至少包含一个虚函数的类称为多态类；


- 静态多态：（早绑定，静态绑定），编译时就能确定的；编译时将函数的实现和函数的调用绑定起来；
- 动态多态：（晚绑定），运行时确定的；以封装和继承为基础；virutal修饰需要形成多态的成员函数，构成虚函数；
- C++中虚函数的主要作用就是实现动态多态；

### b.虚函数

- 虚函数：当基类指针指向一个子类对象时，通过这个指针调用子类和基类的同名成员函数时，**非虚函数调用基类成员函数**，**虚函数调用子类的成员函数**;在某基类中声明为`virtual`并且在一个或多个派生类中被重新定义的成员函数；目的就是实现多态；

- 虚函数表：在对象最前面的位置，存放一个指针`vptr = &obj`，该指针指向一个虚函数表，虚函数表中依次存放该类的虚函数（所有同类对象共用一个虚函数表）；虚函数的调用，需要查询虚函数表，找到地址，再执行；

   ```
   对象：		  虚函数表：
   |_____|    |——————————|————————|
   |..&..| -->|虚函数指针 |    *   |
   |_____|    |——————————|————————|
   |.....|
   |_____|
   |.....|
   |_____|
   ```

- 派生类能继承基类的虚函数表，只要同名成员函数，自动成为虚函数；改写的话，虚函数表也会改写；这也是为什么能够实现动态多态；

- **只有通过指针或引用调用成员函数，才可能形成动态绑定；**

- 虚析构函数：当使用父类的指针，指向堆中申请的子类的对象时，并且还希望通过父类指针释放内存；使用方式：父类析构函数加上`virtual ~Clash_name()`;

   - 用来做基类的类的析构函数一般都是虚函数。

- 纯虚函数：在基类中声明的虚函数，在基类中没有定义，但要求任何派生类都要定义自己的实现方法，目的就是实现一个规范的结构，所有派生类都要定义；实现：`virtual void funtion()=0`,没有函数体，在函数后加=0；

- 抽象类：（abstract）只要含有纯虚函数的类就叫做抽象类，抽象类不能实例化对象；

- 接口类：仅含有纯虚函数的类称为接口类；定义了接口，继承的类需要实现；

- RTTI：运行时类型识别，它使程序能够获取由**基指针或引用**所指向的对象的**实际派生类型**，即允许“用**指向基类的指针或引用**来操作对象”的程序能够获取到**这些指针或引用所指对象的实际派生类型**；在C++中，为了支持RTTI提供了两个操作符：dynamic_cast和typeid。

   - typeid：操作符，返回结果是名为`type_info`的标准库类型的对象的引用
   - dynamic_cast：

- 动态类型：在运行时决定的，是变量或表达式表示的内存中的对象的类型。

- 静态类型：在编译期决定，它是变量声明时的类型或表达式生成的类型；

- 单分配：基于一个类型去选择调用那个函数

- 多分配：由多个类型去选择调用哪个函数

- 子类型多态：以子类型--超类型关系实现多态；

- virtual限制：
   - 不能修饰构造函数

  - 不能修饰静态成员函数

  - 不能修饰非成员函数

  - 不能修饰内联函数，virtual是动态行为，inline是静态行为；

-------

## 5.标准库
### a.IO库

- istream：类型，`typedef basic_istream<char> istream；`
  - cin：一个istream对象，`extern istream cin;`；
- ostream：类型，`typedef basic_ostream<char> ostream；`
  - cout：一个ostream对象，`extern ostream cout;`；
- 缓冲区刷新：
  - 操纵符：endl：刷新换行、flush：刷新、ends：空字符和刷新；
- 关联输入输出：tie，共有两个重载版本，
  - `tie()`:返回关联的out put stream **指针**
  - `tie(ostream* tiestr)`:关联到指定tiestr，并返回一个指向绑定的流的指针；
- 每个流都有一个关联的文件模式（file mode），用来指出如何使用文件：
  - in（以读方式打开）、out（以写方式打开）、app（每次写操作前均定位到文件末尾）、ate（打开文件后立即定位到文件末尾）、trunc（截断文件）、binary（以二进制方式进行IO）；

### b.顺序容器

一个容器就是一些特定类型对象的集合。顺序容器，提供了控制元素存储和访问顺序的能力；这种顺序依赖于元素加入容器时的位置；

### c.泛型算法

- **lambda**表达式：

  - 可调用对象：可以用**调用运算符"`( )`"**调用的对象；包括函数、函数指针、重载了函数调用运算符的类、lambda表达式；

  - lambda 表达式形式：`[捕获列表](参数列表)->return type {function body;};`例如：

    ```c++
    /* 必须有捕获列表和函数体 */
    int i = 3
    auto f = [i](int x)->int{return x+i;};
    cout << f(1) << endl;
    // 显示：4
    ```

- `bind()`参数绑定；

  ```c++
  // a function: (also works with function object: std::divides<double> my_divide;)
  double my_divide (double x, double y) {return x/y;}

  struct MyPair {
    double a,b;
    double multiply() {return a*b;}
  };

  int main () {
    using namespace std::placeholders;    // adds visibility of _1, _2, _3,...

    // binding functions:
    auto fn_five = std::bind (my_divide,10,2);               // returns 10/2
    std::cout << fn_five() << '\n';                          // 5

    auto fn_half = std::bind (my_divide,_1,2);               // returns x/2
    std::cout << fn_half(10) << '\n';                        // 5

    auto fn_invert = std::bind (my_divide,_2,_1);            // returns y/x
    std::cout << fn_invert(10,2) << '\n';                    // 0.2

    auto fn_rounding = std::bind<int> (my_divide,_1,_2);     // returns int(x/y)
    std::cout << fn_rounding(10,3) << '\n';                  // 3

    MyPair ten_two {10,2};

    // binding members:
    auto bound_member_fn = std::bind (&MyPair::multiply,_1); // returns x.multiply()
    std::cout << bound_member_fn(ten_two) << '\n';           // 20

    auto bound_member_data = std::bind (&MyPair::a,ten_two); // returns ten_two.a
    std::cout << bound_member_data() << '\n';                // 10

    return 0;
  }
  ```

- 迭代器：插入迭代器、流迭代器、反向迭代器、移动迭代器；

  - 插入迭代器：用来向给定容器指定位置插入一个元素；
    - back_inserter：尾部插入；只有赋值插入操作，`*i, i++, ++i`只会返回`i`;
    - front_inserter：同上，只有在容器支持`push_front()`操作，才可以使用；
    - inserter：接受一个位置参数，将被插入目标元素之前；该迭代器始终指向创建时的目标元素，即始终在它之前插入；
  - iostream迭代器：
    - istream_iterator:
    - ostream_itreator:
  - 反向迭代器：在容器中从尾元素向首元素反向移动的迭代器。递增一个反向迭代器（++it）会移动到前一个元素；递减（--it）会向后移动一个元素；

### d.关联容器

主要就是各种类型的`map`、`set`

- map：称为关联数组，成员为`typedef pair<const Key, T>value_type;`；

## 6 智能指针

除了静态内存和栈内存，每个程序还拥有一个内存池，这部分内存被称为自由空间（free store)或堆（heap）；C++使用new、delete来为对象分配空间并返回一个指向该对象的指针。为了更容易的使用动态内存，新标准库提供了两种智能指针：`smart_ptr, unique_ptr`;

- `smart_ptr`：也是一个模板，类似vector，需要提供额外信息；

  - 使用智能指针，最标准的方法就是使用`make_shared<>()`的标准库函数分配动态内存；

  - 如果使用new来为智能指针分配空间，必须使用直接初始化：

    ```c++
    shared_ptr<int> p1 = new int(2);	//错误；
    shared_ptr<int> p2(new int(2));		//正确；
    ```

  - make_shared<T> (args)：返回一个shared_ptr，指向一个动态分配的类型T的对象，使用args初始化这个对象；

    - shared_ptr的拷贝和赋值：当进行拷贝和赋值操作时，每个shared_ptr都会记录有多少个其他的`shared_ptr`指向相同的对象；每个`shared_ptr`都有一个关联的计数器，通常称为引用计数（reference count）。**也就是说，shared_ptr知道有多少个指针指向相同的对象，并能在恰当的时候自动释放**

  - shared_ptr的资源销毁：在析构函数中，引用计数减1，当引用计数减为0时，释放这段内存；

  - 不要混用智能指针和普通指针！！以免造成，内存提前销毁导致的错误；

  - `shared_ptr.get()`：会返回一个普通指针，拿到的指针只能进行访问，不能销毁，否则引起程序运行错误；

- `unique_ptr`：拥有它所指向的对象，与shared_ptr不同，某个时刻，只能有一个unique_ptr指向一个给定的对象；

  - `unique_ptr `没有提供类似`make_shared`的标准库函数，当定义unique_ptr时，必须将其绑定到一个new返回的指针，必须采用直接初始化的形式：

    ```C++
    unique_ptr<int> ptr(new int(2));
    ```

  - unique_ptr拥有指向的对象，所以不能拷贝和赋值；

- `weak_ptr`：是一种不控制所指向对象生存周期的智能指针，他指向由一个`shared_ptr `管理的对象，不改变`shared_ptr`的引用计数，

  - 需要一个`shared_ptr`来来初始化；
  - ​

