# CPP
## 1.基础知识
- 变量的初始化：直接初始化（`int x(12) `）和复制初始化（` int x = 12 `）；
- 命名空间：使用命名空间(`using namespace NAME`)，定义命名空间（`namespace NAME`）；
- 引用：就是变量的别名、外号；必须绑定到具体的对象（变量）才有意义；
- c++函数新特性：默认参数，函数重载，内联函数（inline）
- 内存申请：**申请和释放的方式要对应**
``` c++
    // 申请一个类型的内存
    int *a = new int;
    // 需要检查申请是否成功
    if(NULL == a){
    
    }
    // 释放内存空间
    delete a;
    // 申请一块内存
    int *b = new int[10];
    delete []b ;
	//申请一个类内存时可以类名加（），初始化这个类
```
- 初始化列表：当有常量数据成员时必须用初始化列表来初始化
```c++
class Student
{
    Student(int x, int y):a(x),b(y){};
private:
    int a;
    int b;
}
```
- 模版：模版（函数模版和类模版）本身并不是类或函数，相反，可以将模版看作**为编译器生成类或函数编写的说明**。一般需要提供额外的信息来指定模版到底事例化成什么样的类型。
- 字符编码：ASCII、Unicode、UTF-8、UTF-16
    - ASCII：
    - Unicode：是计算机科学领域里的一项业界标准,包括字符集、编码方案等，Unicode只是一个用来映射字符和数字的标准。它对支持字符的数量没有限制，也不要求字符必须占两个、三个或者其它任意数量的字节。两个最流行的Unicode编码方案是UTF-8和UTF-16。
    - UTF-8：当用UTF-8时表示一个字符是可变的，可以是一个、两个、或三个字节，`0xxxxxxx 或 110xxxxx 10xxxxxx 或 1110xxxx 10xxxxxx 10xxxxxx`；
    - UTF-16：任何字符对应的数字都用两个字节来保存；
    - 还需要在文本使用 `EF BB BF` 三个字节表示使用 UTF-8 编码;使用` FE FF `表示使用 UTF-16 编码。
---
## 2.类相关
- 静态数据成员：数据成员的声明前加上static关键字，具有以下特点：
    - 静态数据成员实际上是全局变量；
    - 静态数据成员被类的所有对象共享，包括派生类的对象；
    - 静态数据成员可以成为成员函数的可选参数，而普通数据成员不行；
    - 静态数据成员可以是所属类的类型；
    - 静态数据成员必须**类外初始化**，初始化后才能使用（静态常亮成员除外）；
- 静态成员函数：地址可以用普通函数指针存储，而普通的成员函数（非静态）需要用类成员函数指针来存储；静态成员函数不含有this指针；
- **静态成员可以独立访问，而无需创建任何对象，类名::成员**
- 常数据成员：只能通过初始化列表初始化;
- 常成员函数：不能用来更新类的成员，也不能调用未用const修饰的成员函数；常成员函数可以重载；
- 常对象：只能调用常成员函数；
- 父类（基类），子类（派生类）
- 隐藏和覆盖:当子类与父类存在同名函数时，子类函数会将父类的函数隐藏，默认调用子类的函数；如果希望调用父类的函数，需要在函数名前加上`clase_name::foun()`;
	> 注意：子类函数无法构成父类函数的重载，只能隐藏；
- 虚析构函数：当使用父类的指针，指向堆中申请的子类的对象时，并且还希望通过父类指针释放内存；使用方式：父类析构函数加上`virtual ~Clash_name()`;
	- 用来做基类的类的析构函数一般都是虚函数。
- 虚函数：当基类指针指向一个子类对象时，通过这个指针调用子类和基类的同名成员函数时，**非虚函数调用基类成员函数**，**虚函数调用子类的成员函数**;在某基类中声明为`virtual`并且在一个或多个派生类中被重新定义的成员函数；目的就是实现多态，
- 纯虚函数：在基类中声明的虚函数，在基类中没有定义，但要求任何派生类都要定义自己的实现方法，目的就是实现一个规范的结构，所有派生类都要定义；实现：`virtual void funtion()=0`
- 动态：在运行时决定的，
- 静态：在编译期决定，如函数重载，模板类的非虚函数调用；
- 单分配：基于一个类型去选择调用那个函数
- 多分配：由多个类型去选择调用哪个函数
- 子类型多态：以子类型--超类型关系实现多态；
- 虚继承：为了避免菱形继承中，对底层的子类继承多份最顶层的父类；内存中有多个等成父类空间的现象；继承的时候，加上virtual，就构成虚继承；注意：每个子类都要加virtual
	- C++规则：如果在继承链上存在虚继承的基类，则最底层的子类要负责完成该虚基类部分成员的构造。
- 多继承：一个子类继承多个父类，例如`class C:public A,public B`
- 多重继承：`class B:public A`,`class C:public B`
