# CPP
## 1.基础知识
- 变量的初始化：直接初始化（`int x(12) `）和复制初始化（` int x = 12 `）；

- 命名空间：使用命名空间(`using namespace NAME`)，定义命名空间（`namespace NAME`）；

- 引用：就是变量的别名、外号；必须绑定到具体的对象（变量）才有意义；

- c++函数新特性：默认参数，函数重载，内联函数（inline）

- 内存申请：**申请和释放的方式要对应**
  ``` c++
    // 申请一个类型的内存
    int *a = new int;
    // 需要检查申请是否成功
    if(NULL == a){
    
    }
    // 释放内存空间
    delete a;
    // 申请一块内存
    int *b = new int[10];
    delete []b ;
  //申请一个类内存时可以类名加（），初始化这个类
  ```

- 初始化列表：当有常量数据成员时必须用初始化列表来初始化
  ```c++
  class Student
  {
      Student(int x, int y):a(x),b(y){};
  private:
      int a;
      int b;
  }
  ```

- 模版：模版（函数模版和类模版）本身并不是类或函数，相反，可以将模版看作**为编译器生成类或函数编写的说明**。一般需要提供额外的信息来指定模版到底事例化成什么样的类型。

- 字符编码：ASCII、Unicode、UTF-8、UTF-16
    - ASCII：
    - Unicode：是计算机科学领域里的一项业界标准,包括字符集、编码方案等，Unicode只是一个用来映射字符和数字的标准。它对支持字符的数量没有限制，也不要求字符必须占两个、三个或者其它任意数量的字节。两个最流行的Unicode编码方案是UTF-8和UTF-16。
    - UTF-8：当用UTF-8时表示一个字符是可变的，可以是一个、两个、或三个字节，`0xxxxxxx 或 110xxxxx 10xxxxxx 或 1110xxxx 10xxxxxx 10xxxxxx`；
    - UTF-16：任何字符对应的数字都用两个字节来保存；
    - 还需要在文本使用 `EF BB BF` 三个字节表示使用 UTF-8 编码;使用` FE FF `表示使用 UTF-16 编码。

- 范围for：

    ```c++
    for(declaration:expression)
      	statement
    ```

- 函数的**声明** 和 **定义**：声明无函数体，定义有函数体；函数声明也叫函数原型；

- 函数参数传递：

    - 值传递：存入一般值或指针，需要拷贝；
    - 引用传递：不用拷贝；

- 函数返回类型：

  - 调用一个返回引用类型的函数得到左值；

  - 其他返回右值；

  - c++11规定，函数可以返回花括号包围的值的列表；

    ```c++
    vector<string> process()
    {
      //expected 和 actual是string对象
      if(expected.empty())
        return{};
      else if(expected == actual)
        return{"functionX", "okay"};
    }
    ```

- 尾置返回类型和decltype：

    - 尾置，在参数列表后面指定的类型，例如
      ```c++
      // func接受一个int类型的实参，返回一个指针，指向一个含有10个整数的数组
      auto func(int i) -> int(*)[10]	
      ```

    - decltype：

      ```c++
      // 函数attPty()返回指针，该指针指向一个4个元素数组；

      int odd[] = {1,2,3,4};
      decltype(odd) *attPty(int i)
      {
        
      }
      ```

- 函数重载：函数名相同但形参列表不同，（数量不同或类型不同）

- 默认实参：

- 函数指针：指向的是函数而非对象，函数指针同样需要确定对象，函数返回类型，参数类型和个数；

---
## 2.类相关

- 类的基本思想：数据抽象（data abstration）和封装（encapsulation）】

- 访问控制：c++使用“访问说明符”来加强封装性

  - public
  - private
  - protected

- 友元：类可以允许其他类或者函数返回它的非公有成员；

  ```c++

  ```


- 类的作用域：每个类都有自己的作用域，

- 静态数据成员：数据成员的声明前加上static关键字，具有以下特点：

    - 静态数据成员实际上是全局变量；
    - 静态数据成员被类的所有对象共享，包括派生类的对象；
    - 静态数据成员可以成为成员函数的可选参数，而普通数据成员不行；
    - 静态数据成员可以是所属类的类型；
    - 静态数据成员必须**类外初始化**，初始化后才能使用（静态常亮成员除外），一般放在类的实现文件中初始化（cpp）；

- 静态成员函数：地址可以用普通函数指针存储，而普通的成员函数（非静态）需要用类成员函数指针来存储；静态成员函数不含有this指针；

- **静态成员可以独立访问，而无需创建任何对象，类名::成员**

- 常数据成员：只能通过初始化列表初始化;

- 常成员函数：函数后用const修饰，实际修饰的是this指针，this指向的东西是常量，里面的内容不变；
    ```c++
    void test() const
    {
    };
    ```
    - 不能用来更新类的成员
    - 不能调用未用const修饰的成员函数；
    - 常成员函数可以重载；
    - 扩展：对于常对象的引用或指针都只能调用常量成员函数；

- 常对象：只能调用常成员函数；

- 父类（基类），子类（派生类）

- 隐藏和覆盖:当子类与父类存在同名函数时，子类函数会将父类的函数隐藏，默认调用子类的函数；如果希望调用父类的函数，需要在函数名前加上`clase_name::foun()`;
  > 注意：子类函数无法构成父类函数的重载，只能隐藏；

- 虚析构函数：当使用父类的指针，指向堆中申请的子类的对象时，并且还希望通过父类指针释放内存；使用方式：父类析构函数加上`virtual ~Clash_name()`;
  - 用来做基类的类的析构函数一般都是虚函数。

- 虚函数：当基类指针指向一个子类对象时，通过这个指针调用子类和基类的同名成员函数时，**非虚函数调用基类成员函数**，**虚函数调用子类的成员函数**;在某基类中声明为`virtual`并且在一个或多个派生类中被重新定义的成员函数；目的就是实现多态，

- 纯虚函数：在基类中声明的虚函数，在基类中没有定义，但要求任何派生类都要定义自己的实现方法，目的就是实现一个规范的结构，所有派生类都要定义；实现：`virtual void funtion()=0`

- 动态类型：在运行时决定的，是变量或表达式表示的内存中的对象的类型。

- 静态类型：在编译期决定，它是变量声明时的类型或表达式生成的类型；

- 单分配：基于一个类型去选择调用那个函数

- 多分配：由多个类型去选择调用哪个函数

- 子类型多态：以子类型--超类型关系实现多态；

- 虚继承：为了避免菱形继承中，对底层的子类继承多份最顶层的父类；内存中有多个等成父类空间的现象；继承的时候，加上virtual，就构成虚继承；注意：每个子类都要加virtual
  - C++规则：如果在继承链上存在虚继承的基类，则最底层的子类要负责完成该虚基类部分成员的构造。

- 多继承：一个子类继承多个父类，例如`class C:public A,public B`

- 多重继承：`class B:public A`,`class C:public B`

## 3.构造函数

每个类都分别定义了它的对象被初始化的方式，类通过一个或几个特殊的成员函数来控制其对象的初始化过程，这些函数叫做**构造函数**，

- 构造函数与类名相同，且没有返回类型；

- 如果成员是const、引用，或属于某种未提供默认构造函数的类类型，必须通过构造函数提供初始值；

## 4.多态

- 静态多态：（早绑定），编译时就能确定的；
- 动态多态：（晚绑定），运行时确定的；以封装和继承为基础；virutal修饰需要形成多态的成员函数，构成虚函数；
- virtual限制：
   - 不能修饰构造函数
  - 不能修饰静态成员函数
  - 不能修饰非成员函数
  - 不能修饰内联函数，virtual是动态行为，inline是静态行为；

