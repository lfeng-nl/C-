本文详细介绍STL相关问题

> STL提供6大组件，彼此可以组合套用：1容器，2算法，3迭代器，4仿函数，5适配器，6配置器；

### 1.空间配置器 allocator

- 一般我们用`new int(A)`，其中包含两步：1.调用auto p = `::operator new(size(A))` 配置内存；2.调用构造函数构造对象`new(p) A()` ；同理，`delete`也一样；; 1.调用析构函数`p->~A()`2.释放内存`::operator delete()`
- 内存配置：`::operator new(），::operator delete()`,相当于C中的`malloc().free()`;
- 空间的配置和释放：==一级配置器==：直接使用`malloc，realloc，free`申请释放一大块内存，交由二级配置器；==二级配置器==：维护空闲链表，负责向上级申请提供内存（大于128B，直接交由一级配置器申请，否则从`free-list`分拨），空间不足向一级配置器申请；
- `free-list`：`union`类型链表；

### 2.iterator

迭代器是一种抽象概念；`iterator`的定义：提供一种方法，使之能够依次序寻访某个聚合物（容器）所含的各个元素，而又无需暴露该聚合物的内部表述方式；

> STL 的中心思想在于：将数据容器（containers）和算法（algorithms）分开，彼此独立设计，最后在以一胶着剂将他们粘在一起；

- 迭代器是一种smart pointer，
- 偏特化：
  - 模板特例化：模板特化的目的就是==对于某一种变量类型具有不同的实现==；
  - 偏特化Partial Specialization：提供另一份template定义式，而其本身仍是template

## 序列式容器

所谓序列式容器，其中元素都可序（ordered），但未必有序（sorted）；

### 3.vector

`vector` 是动态空间，随着元素的加入，它的内部机制会自行扩充空间以容纳新元素；实现关键在于对其大小的控制以及重新配置时数据移动效率；

- `vector`的析构函数需要销毁两部分，一个是已经分配的有数据的空间，一部分是申请但未使用的空间；
- `vector`提供的迭代器就是普通指针；
- 新增元素时，如果超过适当的容量，则会==扩充至两倍==。如果两倍容量仍不足，就扩张至足够大的容量。
- 对于`vector`一旦引起空间重新配置，指向原`vector`的迭代器就失效了。
- 插入删除操作会导致元素移动，甚至空间的再分配；

### 4.list

双向链表，快速插入和删除；

- `list`结点：包含指针和数据内容的结构体；
- `liist`迭代器：一个提供递增，递减，取值，成员取用等操作的对象；内部含有一个普通指针，指向结点；
- ​